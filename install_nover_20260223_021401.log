INSTALL ZIP: C:\p\c++\patch\v14_faststepper_quality_upgrade_patch.zip
TIME: 2026-02-23 02:14:01
TARGET_ROOT: C:\p\c++\vPlotterV1
DEST (DEST_SUBDIR): C:\p\c++\vPlotterV1
VERSION:  PATCH_ID: 
INSTALL_TXT: INSTALL.txt
BACKUP_ENABLED: True
BACKUP_ZIP: C:\p\c++\backup\backup_vPlotterV1_vnone_none_20260223_021352.zip
PRECHECK: replace=3 add=1 total=4

--- DIFF (line numbers) src/stepper_backend.h ---
HUNK old 11-20  new 11-31
+ new:    14 // Be defensive: if the library is not installed but the flag is set, fall back to AccelStepper.
+ new:    15 // This prevents "it builds on my machine" surprises.
- old:    15   #include <FastAccelStepper.h>
+ new:    17   #if __has_include(<FastAccelStepper.h>)
+ new:    18     #include <FastAccelStepper.h>
+ new:    19     #define STEPPER_BACKEND_HAS_FAST 1
+ new:    20   #else
+ new:    21     #include <AccelStepper.h>
+ new:    22     #define STEPPER_BACKEND_HAS_FAST 0
+ new:    23     #undef USE_FAST_ACCELSTEPPER
+ new:    24     #define USE_FAST_ACCELSTEPPER 0
+ new:    25   #endif
+ new:    28   #define STEPPER_BACKEND_HAS_FAST 0

--- DIFF (line numbers) src/movement.h ---
HUNK old 169-174  new 169-177
+ new:   172 
+ new:   173     // Planner smoothing state. Keeps behaviour stable while allowing lookaheadSegments to matter.
+ new:   174     double lastCornerFactor = 1.0;
HUNK old 192-198  new 195-201
- old:   195     double computeCornerFactor(double dx, double dy) const;
+ new:   198     double computeCornerFactor(double dx, double dy, double requestedSpeedSteps);

--- DIFF (line numbers) src/movement.cpp ---
HUNK old 236-243  new 236-245
- old:   239     constexpr int solver_max_iterations = 20;
- old:   240     constexpr double gamma_delta_termination = 0.25 / 180.0 * PI;
+ new:   239     // Higher precision is important when we segment moves into many small XY steps.
+ new:   240     // Too-loose termination accumulates visible curvature on long straight lines.
+ new:   241     constexpr int solver_max_iterations = 60;
+ new:   242     constexpr double gamma_delta_termination = 0.05 / 180.0 * PI;
HUNK old 246-252  new 248-254
- old:   249         if (abs(gamma_last - gamma) < gamma_delta_termination) break;
+ new:   251         if (fabs(gamma_last - gamma) < gamma_delta_termination) break;
HUNK old 267-287  new 269-324
- old:   270 double Movement::computeCornerFactor(double dx, double dy) const {
+ new:   272 double Movement::computeCornerFactor(double dx, double dy, double requestedSpeedSteps) {
+ new:   277     // Very small segments should not be corner-limited again.
+ new:   278     if (plannerCfg.minSegmentLenMM > 0.0) {
+ new:   279         const double lenMm = (double)len / (double)std::max(1, mmToSteps(1.0));
+ new:   280         if (lenMm < plannerCfg.minSegmentLenMM) return 1.0;
+ new:   281     }
+ new:   282 
+ new:   286     // Collinear simplification: if almost straight, don't corner-limit.
+ new:   287     if (plannerCfg.collinearDeg > 0.0) {
+ new:   288         const double angleDeg = angle * 180.0 / PI;
+ new:   289         if (angleDeg < plannerCfg.collinearDeg) return 1.0;
+ new:   290     }
+ new:   291 
- old:   280     // Junction-deviation style simple scaler
+ new:   294     // Base slowdown (legacy behaviour)
- old:   284     return f;
+ new:   298 
+ new:   299     // Junction-deviation limit: convert corner angle into a max junction speed and clamp by requested speed.
+ new:   300     // This makes junctionDeviationMM actually matter.
+ new:   301     if (plannerCfg.junctionDeviationMM > 0.0 && requestedSpeedSteps > 1.0) {
+ new:   302         const double sinHalf = sin(angle * 0.5);
+ new:   303         const double denom = 1.0 - sinHalf;
+ new:   304         if (sinHalf > 1e-6 && denom > 1e-6) {
+ new:   305             const double jdSteps = (double)std::max(1, mmToSteps(plannerCfg.junctionDeviationMM));
+ new:   306             const double a = (double)std::max(1.0f, accelerationSteps);
+ new:   307             const double vJ = sqrt((a * jdSteps * sinHalf) / denom);
+ new:   308             double jdFactor = vJ / requestedSpeedSteps;
+ new:   309             if (jdFactor < 0.05) jdFactor = 0.05;
+ new:   310             if (jdFactor > 1.0) jdFactor = 1.0;
+ new:   311             if (jdFactor < f) f = jdFactor;
+ new:   312         }
+ new:   313     }
+ new:   314 
+ new:   315     // Simple lookahead smoothing: higher lookaheadSegments => smoother factor changes.
+ new:   316     int n = plannerCfg.lookaheadSegments;
+ new:   317     if (n < 1) n = 1;
+ new:   318     if (n > 200) n = 200;
+ new:   319     const double alpha = 1.0 / (double)std::max(1, n / 8);
+ new:   320     lastCornerFactor = lastCornerFactor + alpha * (f - lastCornerFactor);
+ new:   321     return lastCornerFactor;
HUNK old 328-334  new 365-371
- old:   331     double cornerFactor = computeCornerFactor(dx, dy);
+ new:   368     double cornerFactor = computeCornerFactor(dx, dy, (double)speed);

CHANGELOG: C:\p\c++\vPlotterV1\CHANGELOG_unknown_20260223_021401.md
INSTALL DONE
