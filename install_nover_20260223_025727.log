INSTALL ZIP: C:\p\c++\patch\v14_patch_fix_jog_and_max.zip
TIME: 2026-02-23 02:57:27
TARGET_ROOT: C:\p\c++\vPlotterV1
DEST (DEST_SUBDIR): C:\p\c++\vPlotterV1
VERSION:  PATCH_ID: 
INSTALL_TXT: (none)
BACKUP_ENABLED: True
BACKUP_ZIP: C:\p\c++\backup\backup_vPlotterV1_vnone_none_20260223_025709.zip
PRECHECK: replace=1 add=0 total=1

--- DIFF (line numbers) src/movement.cpp ---
HUNK old 5-11  new 5-10
- old:     8 #include <algorithm>
HUNK old 13-35  new 12-26
- old:    16     #if USE_FAST_ACCELSTEPPER
- old:    17     leftMotor = new FastStepperBackend(LEFT_STEP_PIN, LEFT_DIR_PIN);
- old:    18 #else
- old:    19     leftMotor = new AccelStepperBackend(LEFT_STEP_PIN, LEFT_DIR_PIN);
- old:    20 #endif
+ new:    15     leftMotor = new AccelStepper(AccelStepper::DRIVER, LEFT_STEP_PIN, LEFT_DIR_PIN);
- old:    27 #if USE_FAST_ACCELSTEPPER
- old:    28     rightMotor = new FastStepperBackend(RIGHT_STEP_PIN, RIGHT_DIR_PIN);
- old:    29 #else
- old:    30     rightMotor = new AccelStepperBackend(RIGHT_STEP_PIN, RIGHT_DIR_PIN);
- old:    31 #endif
- old:    32     rightMotor->setPinsInverted(true);
+ new:    22     rightMotor = new AccelStepper(AccelStepper::DRIVER, RIGHT_STEP_PIN, RIGHT_DIR_PIN);
+ new:    23     rightMotor->setPinsInverted(true, false, false);
HUNK old 100-162  new 91-138
- old:   103     // Manual jog: must use MaxSpeed + Acceleration because runSteppers() uses run()
- old:   107 
- old:   108     const float accel = (float)std::max(1, accelerationSteps);
+ new:    97     leftMotor->setMinPulseWidth(_leftPulseWidthUs);
+ new:    98 
+ new:    99     const float accel = (float)std::max(1.0, (double)accelerationSteps);
+ new:   100     const float vmax  = (float)std::max(1, printSpeedSteps);
+ new:   101 
- old:   110 
- old:   111     // Use moveSpeedSteps for tool jogging (pen is typically up). Prevent "stuck at 0" MaxSpeed.
- old:   112     const float v = (float)std::max(1, moveSpeedSteps);
- old:   113     leftMotor->setMaxSpeed(v);
+ new:   103     leftMotor->setMaxSpeed(vmax);
- old:   117         moving = true;
- old:   118         return;
- old:   119     }
- old:   120     if (dir < 0) {
+ new:   107     } else if (dir < 0) {
- old:   122         moving = true;
- old:   123         return;
- old:   124     }
- old:   125 
- old:   126     // dir == 0 -> stop (decelerate)
- old:   127     leftMotor->stop();
+ new:   109     } else {
+ new:   110         leftMotor->stop();
+ new:   111     }
+ new:   112 
- old:   132     // Manual jog: must use MaxSpeed + Acceleration because runSteppers() uses run()
- old:   136 
- old:   137     const float accel = (float)std::max(1, accelerationSteps);
+ new:   120     rightMotor->setMinPulseWidth(_rightPulseWidthUs);
+ new:   121 
+ new:   122     const float accel = (float)std::max(1.0, (double)accelerationSteps);
+ new:   123     const float vmax  = (float)std::max(1, printSpeedSteps);
+ new:   124 
- old:   139 
- old:   140     // Ensure pulse width is always applied consistently (if AccelStepper backend)
- old:   141     rightMotor->setMinPulseWidth(_rightPulseWidthUs);
- old:   142 
- old:   143     // Use moveSpeedSteps for tool jogging (pen is typically up). Prevent "stuck at 0" MaxSpeed.
- old:   144     const float v = (float)std::max(1, moveSpeedSteps);
- old:   145     rightMotor->setMaxSpeed(v);
+ new:   126     rightMotor->setMaxSpeed(vmax);
- old:   149         moving = true;
- old:   150         return;
- old:   151     }
- old:   152     if (dir < 0) {
+ new:   130     } else if (dir < 0) {
- old:   154         moving = true;
- old:   155         return;
- old:   156     }
- old:   157 
- old:   158     // dir == 0 -> stop (decelerate)
- old:   159     rightMotor->stop();
+ new:   132     } else {
+ new:   133         rightMotor->stop();
+ new:   134     }
+ new:   135 
HUNK old 227-240  new 203-214
- old:   230     // Smaller step improves straightness when many tiny XY segments are executed
- old:   231     constexpr double gamma_step = 0.05 * PI / 180.0;
+ new:   206     constexpr double gamma_step = 0.20 * PI / 180.0;
- old:   236     // Scan full window and pick best. Do NOT early-return on first "worse" sample.
- old:   237     for (double gamma = gamma_init - gamma_search_window; gamma >= gamma_min && gamma <= gamma_max && gamma <= gamma_init + gamma_search_window; gamma += gamma_step) {
+ new:   211     for (double gamma = gamma_init - gamma_search_window; gamma > gamma_min && gamma < gamma_max && gamma <= gamma_init + gamma_search_window; gamma += gamma_step) {
HUNK old 248-256  new 222-232
- old:   251         if (fabs(T_delta) < fabs(T_delta_best)) {
+ new:   225         if (abs(T_delta) < abs(T_delta_best)) {
+ new:   228         } else {
+ new:   229             return gamma_best;
HUNK old 269-278  new 245-252
- old:   272     // Higher precision is important when we segment moves into many small XY steps.
- old:   273     // Too-loose termination accumulates visible curvature on long straight lines.
- old:   274     constexpr int solver_max_iterations = 60;
- old:   275     constexpr double gamma_delta_termination = 0.05 / 180.0 * PI;
+ new:   248     constexpr int solver_max_iterations = 20;
+ new:   249     constexpr double gamma_delta_termination = 0.25 / 180.0 * PI;
HUNK old 281-287  new 255-261
- old:   284         if (fabs(gamma_last - gamma) < gamma_delta_termination) break;
+ new:   258         if (abs(gamma_last - gamma) < gamma_delta_termination) break;
HUNK old 302-357  new 276-296
- old:   305 double Movement::computeCornerFactor(double dx, double dy, double requestedSpeedSteps) {
+ new:   279 double Movement::computeCornerFactor(double dx, double dy) const {
- old:   310     // Very small segments should not be corner-limited again.
- old:   311     if (plannerCfg.minSegmentLenMM > 0.0) {
- old:   312         const double lenMm = (double)len / (double)std::max(1, mmToSteps(1.0));
- old:   313         if (lenMm < plannerCfg.minSegmentLenMM) return 1.0;
- old:   314     }
- old:   315 
- old:   319     // Collinear simplification: if almost straight, don't corner-limit.
- old:   320     if (plannerCfg.collinearDeg > 0.0) {
- old:   321         const double angleDeg = angle * 180.0 / PI;
- old:   322         if (angleDeg < plannerCfg.collinearDeg) return 1.0;
- old:   323     }
- old:   324 
- old:   327     // Base slowdown (legacy behaviour)
+ new:   289     // Junction-deviation style simple scaler
- old:   331 
- old:   332     // Junction-deviation limit: convert corner angle into a max junction speed and clamp by requested speed.
- old:   333     // This makes junctionDeviationMM actually matter.
- old:   334     if (plannerCfg.junctionDeviationMM > 0.0 && requestedSpeedSteps > 1.0) {
- old:   335         const double sinHalf = sin(angle * 0.5);
- old:   336         const double denom = 1.0 - sinHalf;
- old:   337         if (sinHalf > 1e-6 && denom > 1e-6) {
- old:   338             const double jdSteps = (double)std::max(1, mmToSteps(plannerCfg.junctionDeviationMM));
- old:   339             const double a = ((double)accelerationSteps < 1.0) ? 1.0 : (double)accelerationSteps;
- old:   340             const double vJ = sqrt((a * jdSteps * sinHalf) / denom);
- old:   341             double jdFactor = vJ / requestedSpeedSteps;
- old:   342             if (jdFactor < 0.05) jdFactor = 0.05;
- old:   343             if (jdFactor > 1.0) jdFactor = 1.0;
- old:   344             if (jdFactor < f) f = jdFactor;
- old:   345         }
- old:   346     }
- old:   347 
- old:   348     // Simple lookahead smoothing: higher lookaheadSegments => smoother factor changes.
- old:   349     int n = plannerCfg.lookaheadSegments;
- old:   350     if (n < 1) n = 1;
- old:   351     if (n > 200) n = 200;
- old:   352     const double alpha = 1.0 / (double)std::max(1, n / 8);
- old:   353     lastCornerFactor = lastCornerFactor + alpha * (f - lastCornerFactor);
- old:   354     return lastCornerFactor;
+ new:   293     return f;
HUNK old 361-389  new 300-319
- old:   364 double tx = x;
- old:   365 double ty = y;
- old:   366 
- old:   367 // Direction based on original target (before backlash), so compensation triggers reliably.
- old:   368 double dx0 = tx - X;
- old:   369 double dy0 = ty - Y;
- old:   370 int dirX0 = (dx0 > 1e-6) ? 1 : ((dx0 < -1e-6) ? -1 : 0);
- old:   371 int dirY0 = (dy0 > 1e-6) ? 1 : ((dy0 < -1e-6) ? -1 : 0);
- old:   372 
- old:   373 if (lastDirX != 0 && dirX0 != 0 && dirX0 != lastDirX) tx += dirX0 * plannerCfg.backlashXmm;
- old:   374 if (lastDirY != 0 && dirY0 != 0 && dirY0 != lastDirY) ty += dirY0 * plannerCfg.backlashYmm;
- old:   375 
- old:   376 // Clamp
- old:   377 tx = std::max(0.0, std::min(width, tx));
- old:   378 if (ty < 0.0) ty = 0.0;
- old:   379 
- old:   380 // IMPORTANT: recompute segment vector after backlash/clamp. This is the real movement.
- old:   381 const double dx = tx - X;
- old:   382 const double dy = ty - Y;
- old:   383 int dirX = (dx > 1e-6) ? 1 : ((dx < -1e-6) ? -1 : 0);
- old:   384 int dirY = (dy > 1e-6) ? 1 : ((dy < -1e-6) ? -1 : 0);
- old:   385 
- old:   386 const auto lengths = getBeltLengths(tx, ty);
+ new:   303     double tx = x;
+ new:   304     double ty = y;
+ new:   305     const double dx = tx - X;
+ new:   306     const double dy = ty - Y;
+ new:   307     int dirX = (dx > 1e-6) ? 1 : ((dx < -1e-6) ? -1 : 0);
+ new:   308     int dirY = (dy > 1e-6) ? 1 : ((dy < -1e-6) ? -1 : 0);
+ new:   309 
+ new:   310     if (lastDirX != 0 && dirX != 0 && dirX != lastDirX) tx += dirX * plannerCfg.backlashXmm;
+ new:   311     if (lastDirY != 0 && dirY != 0 && dirY != lastDirY) ty += dirY * plannerCfg.backlashYmm;
+ new:   312 
+ new:   313     tx = std::max(0.0, std::min(width, tx));
+ new:   314     if (ty < 0.0) ty = 0.0;
+ new:   315 
+ new:   316     const auto lengths = getBeltLengths(tx, ty);
HUNK old 398-404  new 328-334
- old:   401     double cornerFactor = computeCornerFactor(dx, dy, (double)speed);
+ new:   331     double cornerFactor = computeCornerFactor(dx, dy);
HUNK old 410-451  new 340-368
- old:   413 double accelScale = 1.0 - ((1.0 - cornerFactor) * plannerCfg.sCurveFactor);
- old:   414 if (accelScale < 0.2) accelScale = 0.2;
- old:   415 
- old:   416 const float localAccelBase = (float)std::max(1.0, accelerationSteps * accelScale);
- old:   417 
- old:   418 const float moveTime = (float)maxDelta / (float)targetSpeed;
+ new:   343     // Approximate S-curve by lowering accel around corners
+ new:   344     double accelScale = 1.0 - ((1.0 - cornerFactor) * plannerCfg.sCurveFactor);
+ new:   345     if (accelScale < 0.2) accelScale = 0.2;
+ new:   346     const float localAccel = (float)std::max(1.0, (double)accelerationSteps * accelScale);
+ new:   347 leftMotor->setAcceleration(localAccel);
+ new:   348     rightMotor->setAcceleration(localAccel);
+ new:   349 
+ new:   350     const float moveTime = (float)maxDelta / (float)targetSpeed;
- old:   425 rightMotor->enableOutputs();
- old:   426 
- old:   427 leftMotor->setMaxSpeed(leftSpeed);
- old:   428 rightMotor->setMaxSpeed(rightSpeed);
- old:   429 
- old:   430 const float refV = (float)targetSpeed;
- old:   431 float aL = localAccelBase;
- old:   432 float aR = localAccelBase;
- old:   433 
- old:   434 if (refV > 1.0f) {
- old:   435     aL = localAccelBase * (leftSpeed / refV);
- old:   436     aR = localAccelBase * (rightSpeed / refV);
- old:   437 }
- old:   438 
- old:   439 if (aL < 1.0f) aL = 1.0f;
- old:   440 if (aR < 1.0f) aR = 1.0f;
- old:   441 
- old:   442 leftMotor->setAcceleration(aL);
- old:   443 rightMotor->setAcceleration(aR);
- old:   444 
- old:   445 leftMotor->moveTo(leftLegSteps);
- old:   446 rightMotor->moveTo(rightLegSteps);
- old:   447 
- old:   448 X = tx;
+ new:   357     rightMotor->enableOutputs();
+ new:   358 
+ new:   359     leftMotor->setMaxSpeed(leftSpeed);
+ new:   360     leftMotor->moveTo(leftLegSteps);
+ new:   361 
+ new:   362     rightMotor->setMaxSpeed(rightSpeed);
+ new:   363     rightMotor->moveTo(rightLegSteps);
+ new:   364 
+ new:   365     X = tx;
HUNK old 528-550  new 445-470
- old:   531   // Enable pin is optional. With FastAccelStepper it is recommended for clean driver enable/disable.
- old:   532   if (leftMotor)  leftMotor->configureEnablePin(_leftEnablePin, true);
- old:   533   if (rightMotor) rightMotor->configureEnablePin(_rightEnablePin, true);
+ new:   448   if (leftMotor)  leftMotor->setEnablePin(_leftEnablePin);
+ new:   449   if (rightMotor) rightMotor->setEnablePin(_rightEnablePin);
- old:   539 void Movement::setPulseWidths(int /*leftUs*/, int /*rightUs*/) {
- old:   540   // Fixed pulse width for stability. Do not make this configurable at runtime.
- old:   541   const int us = FIXED_PULSE_US;
- old:   542 
- old:   543   _leftPulseWidthUs = us;
- old:   544   _rightPulseWidthUs = us;
- old:   545 
- old:   546   if (leftMotor) leftMotor->setMinPulseWidth(us);
- old:   547   if (rightMotor) rightMotor->setMinPulseWidth(us);
+ new:   455 void Movement::setPulseWidths(int leftUs, int rightUs) {
+ new:   456   if (leftUs < 1) leftUs = 1;
+ new:   457   if (rightUs < 1) rightUs = 1;
+ new:   458   if (leftUs > 1000) leftUs = 1000;
+ new:   459   if (rightUs > 1000) rightUs = 1000;
+ new:   460 
+ new:   461   _leftPulseWidthUs = leftUs;
+ new:   462   _rightPulseWidthUs = rightUs;
+ new:   463 
+ new:   464   if (leftMotor) leftMotor->setMinPulseWidth(_leftPulseWidthUs);
+ new:   465   if (rightMotor) rightMotor->setMinPulseWidth(_rightPulseWidthUs);
+ new:   466 
+ new:   467   WebLog::info("Pulse widths updated: left=" + String(_leftPulseWidthUs) + "us right=" + String(_rightPulseWidthUs) + "us");

CHANGELOG: C:\p\c++\vPlotterV1\CHANGELOG_unknown_20260223_025727.md
INSTALL DONE
